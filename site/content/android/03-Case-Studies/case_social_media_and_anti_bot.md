---
title: "社交媒体 App 与风控案例"
date: 2025-02-13
tags: ["Native层", "签名验证", "Frida", "案例分析", "代理池", "Ghidra"]
weight: 10
---

# 社交媒体 App 与风控案例

> **📚 前置知识**
>
> 本案例涉及以下核心技术，建议先阅读相关章节：
>
> - **[密码学分析](../01-Recipes/Network/crypto_analysis.md)** - 理解 API 签名算法的逆向方法
> - **[Frida 完整指南](../02-Tools/Dynamic/frida_guide.md)** - 使用 Hook 定位签名生成函数

社交媒体 App（如 X、Instagram、TikTok）是爬虫和自动化工具最常光顾的地方。因此，这些 App 的开发者在客户端和服务器端都部署了极其复杂的安全与风控系统，以保护用户数据和平台生态。本案例将聚焦于这些 App 中常见的风控对抗技术。

---

## 核心分析目标

1. **API 签名算法逆向**: 几乎所有社交 App 的核心 API 请求都包含一个或多个签名参数（如 `X-Signature`, `X-Gorgon`）。这些签名是请求合法性的证明，也是逆向的主要目标。
2. **设备指纹分析**: 理解 App 如何收集设备信息（硬件、软件、网络环境等）来生成唯一的设备 ID (`device_id`)，并用于风控决策。
3. **业务风控逻辑分析**: 分析 App 在关键业务点（如注册、登录、点赞、评论）的风控策略，例如人机验证（滑块验证码、点图验证等）。

---

## 案例：分析一个典型社交 App 的 API 签名流程

### 第 1 步：定位签名参数

**目标**: 识别出 API 请求中哪个参数是签名。

1. **网络抓包**: 使用 Charles 或 Mitmproxy 拦截 App 的网络流量。刷新首页动态（timeline）的请求是最好的分析对象，因为它通常包含了最复杂的签名。
2. **观察请求**: 查看一个典型的 API 请求，例如 `/api/v2/feed`。你会注意到其 URL 参数或请求头 (Headers) 中存在一些看起来像哈希值的、无明显语义的参数。

   - **URL 参数**: `...&mas=01&as=a1...&ts=166...&ssmix=a...`
   - **请求头**: `X-Gorgon: 0404...`, `X-Khronos: 166...`

3. **参数筛选**: 通过多次重复请求，比较参数的变化规律。
   - **不变的**: `device_id`, `os_version` 等，通常是设备指纹的一部分。
   - **随时间变化的**: `ts`, `X-Khronos` 等，通常是时间戳。
   - **每次请求都随机变化的**: `mas`, `as`, `X-Gorgon` 等，这些就是我们要找的核心签名。

### 第 2 步：定位签名生成代码

**目标**: 找到在客户端生成这些签名的代码。这是整个流程中最关键、也最困难的一步。

1. **全局搜索**: 在 `jadx-gui` 中，全局搜索上一步识别出的参数名，如 `X-Gorgon`。如果运气好，你能直接定位到构建网络请求的地方。

2. **Hook 大法**: 如果搜索无果（通常是因为参数名在代码中被加密或混淆了），Frida Hook 将是你的主力武器。

   - **Hook 网络库**: 从网络请求的源头入手。Hook `OkHttp` 的 `Request.Builder.addHeader` 或 `url()` 方法，打印出调用栈。

   ```javascript
   Java.perform(function () {
     var Builder = Java.use("okhttp3.Request$Builder");
     Builder.addHeader.implementation = function (name, value) {
       if (name === "X-Gorgon") {
         // Found it! Print call stack
         console.log("Found X-Gorgon being added: " + value);
         console.log(
           Java.use("android.util.Log").getStackTraceString(
             Java.use("java.lang.Exception").$new()
           )
         );
       }
       return this.addHeader(name, value);
     };
   });
   ```

3. **静态分析签名函数**: 定位到具体的签名函数后（例如，`SignHelper.getSign(params)`），在 Ghidra 或 IDA 中仔细分析其逻辑。

   - **输入**: 它的输入通常是一个 `Map` 或 `List`，包含了所有要参与签名的业务参数（如 `user_id`）和设备指纹参数。

   - **逻辑**: 函数内部逻辑通常是：
     1. 对所有参数按 key 进行字典序排序。
     2. 将排序后的 key-value 对拼接成一个长的字符串。
     3. 将固定的盐（salt，可能硬编码或从 Native 获取）拼接到字符串的头部或尾部。
     4. 对最终的字符串进行 MD5 或 HMAC-SHA256 哈希。
     5. 有时还会进行额外的变换，如 Base64 编码或自定义的字节操作。

   - **Native 混淆**: 越来越多的 App 将核心的签名算法（特别是盐）放到 `.so` 文件中，并使用 OLLVM 或 VMP 等技术进行混淆，以对抗静态分析。这时，就需要结合动态调试来一步步跟踪其执行流程。

### 第 3 步：模拟签名与自动化

**目标**: 在你自己的 Python 或其他语言脚本中，重新实现签名算法，从而可以脱离 App 独立发起合法的 API 请求。

1. **代码复现**: 根据静态分析的结果，用 Python 完整地复现整个签名流程。每一个细节都要精确匹配，包括参数的排序、拼接方式、哈希算法等。

2. **获取设备参数**: 签名依赖的设备指纹参数（`device_id`, `install_id` 等）通常在 App 首次启动时生成并存储在本地。你需要 Hook 相关的函数来获取一套合法的设备参数，并在你的脚本中使用它们。

3. **风控对抗**:
   - **滑块验证码**: 当服务器检测到你的请求异常时（例如，IP 地址异常、请求频率过高），它可能会返回一个需要进行人机验证的响应。你需要分析验证码的逻辑，这通常涉及到对一个 `JavaScript` 文件的逆向，分析其滑块轨迹加密算法。
   - **请求频率**: 模拟真实用户的行为，在请求之间加入随机的延迟。
   - **代理 IP**: 使用高质量的代理 IP 池来避免单个 IP 被封禁。

---

## 总结

社交媒体 App 的逆向是典型的"数据在客户端，但由服务器规则校验"的场景。其核心是对抗，而不只是解密。

- **签名是核心**: 逆向签名算法是所有工作的基础。
- **动静结合**: 需要反复在静态分析（Ghidra/IDA）和动态验证（Frida）之间切换。
- **风控是持续的斗争**: 即使你成功逆向了签名，服务器端的风控策略也在不断演进。这是一个长期的、动态的攻防过程。
