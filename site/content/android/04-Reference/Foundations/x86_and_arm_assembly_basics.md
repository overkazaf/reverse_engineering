---
title: "x86 与 ARM 汇编基础指南"
date: 2024-05-21
tags: ["基础知识", "Smali", "Android", "ARM汇编", "DEX"]
weight: 10
---

# x86 与 ARM 汇编基础指南

汇编语言是与计算机硬件直接对话的低级编程语言，是逆向工程、系统编程和性能优化的基石。在当今世界，x86 和 ARM 是两种最主流的指令集架构 (ISA)。理解它们的核心概念与差异对于逆向工程师至关重要。

- **x86**: 由 Intel 主导，采用**CISC (复杂指令集计算机)** 设计。指令长度可变，功能强大但复杂，主要用于桌面和服务器。

- **ARM**: 由 ARM Holdings 设计，采用**RISC (精简指令集计算机)** 设计。指令长度固定，设计简洁优雅，功耗低，主宰了移动和嵌入式设备领域。

---

## 目录

- [x86 与 ARM 汇编基础指南](#x86-与-arm-汇编基础指南)
  - [目录](#目录)
  - [x86 汇编 (IA-32)](#x86-汇编-ia-32)
    - [核心寄存器](#核心寄存器)
    - [常用指令](#常用指令)
    - [调用约定 (Calling Convention)](#调用约定-calling-convention)
  - [ARM 汇编 (ARMv7)](#arm-汇编-armv7)
    - [核心寄存器](#核心寄存器-1)
    - [加载/存储 (Load/Store) 架构](#加载存储-loadstore-架构)
    - [常用指令](#常用指令-1)
    - [调用约定 (AAPCS)](#调用约定-aapcs)
  - [x86 vs. ARM 核心差异对比](#x86-vs-arm-核心差异对比)

---

## x86 汇编 (IA-32)

以 32 位 x86 架构为例，其设计复杂而灵活。

### 核心寄存器

8 个 32 位通用寄存器，它们有主要用途，但在很多情况下可以通用。

| 寄存器  | 主要用途                                                                     |
| :------ | :--------------------------------------------------------------------------- |
| **EAX** | **累加器 (Accumulator)**: 通常用于存放函数返回值和算术运算结果。             |
| **EBX** | **基址 (Base)**: 常作为数据段的基址指针。                                    |
| **ECX** | **计数器 (Counter)**: 常用于循环计数。                                       |
| **EDX** | **数据 (Data)**: 常用于存放数据，特别是在乘除法中与 EAX 配合。               |
| **ESP** | **栈指针 (Stack Pointer)**: **永远指向栈顶**。                               |
| **EBP** | **基址指针 (Base Pointer)**: **永远指向当前函数栈帧的底部**。                |
| **ESI** | **源变址 (Source Index)**: 字符串和内存操作中的源地址。                      |
| **EDI** | **目的变址 (Destination Index)**: 字符串和内存操作中的目的地址。             |
| **EIP** | **指令指针 (Instruction Pointer)**: **永远指向下一条将要执行的指令的地址**。 |

### 常用指令

- **数据传送**:
- `MOV dest, src`: 将 `src` 的值赋给 `dest`。 (e.g., `MOV EAX, EBX`)

- `PUSH val`: 将 `val` 压入栈顶，`ESP` 减 4。

- `POP reg`: 从栈顶弹出一个值到 `reg`，`ESP` 加 4。

- `LEA reg, [mem]`: 将 `mem` 的**有效地址**加载到 `reg`，而不是其内容。
- **算术运算**:
- `ADD dest, src`: `dest = dest + src`

- `SUB dest, src`: `dest = dest - src`

- `INC reg`: `reg = reg + 1`

- `DEC reg`: `reg = reg - 1`
- **逻辑与跳转**:
- `CMP reg1, reg2`: 比较 `reg1` 和 `reg2` (实际是做减法)，并根据结果设置标志位。

- `JMP target`: 无条件跳转到 `target` 地址。

- `JE target`: 如果相等 (Zero Flag=1) 则跳转。

- `JNE target`: 如果不相等 (Zero Flag=0) 则跳转。

- `JG/JL/JGE/JLE`: 大于/小于/大于等于/小于等于时跳转。
- **函数调用**:
- `CALL target`: 将 `EIP` 的下一条指令地址压栈，然后跳转到 `target`。

- `RET`: 从栈顶弹出地址，并跳转到该地址。

### 调用约定 (Calling Convention)

规定了函数如何传递参数和返回结果。常见于 32 位 Windows 的是 `stdcall`，而 Linux/macOS 上常见 `cdecl`。

- **`cdecl`**:
- 参数从右到左依次压入栈中。

- **调用者**负责在函数返回后清理栈。
- **`stdcall`**:
- 参数从右到左依次压入栈中。

- **被调用者**自己负责在返回前清理栈。

---

## ARM 汇编 (ARMv7)

以 32 位 ARM 架构为例，其设计简洁而高效。

### 核心寄存器

共有 16 个 32 位通用寄存器 (R0-R15)。

| 寄存器       | 别名   | 主要用途                                                                |
| :----------- | :----- | :---------------------------------------------------------------------- |
| **R0 - R3**  |        | **参数/返回值**: 用于传递函数的前 4 个参数，`R0` 也用于存放函数返回值。 |
| **R4 - R12** |        | 通用寄存器，用于保存局部变量。                                          |
| **R13**      | **SP** | **栈指针 (Stack Pointer)**: 指向栈顶。                                  |
| **R14**      | **LR** | **链接寄存器 (Link Register)**: **存储函数的返回地址**。                |
| **R15**      | **PC** | **程序计数器 (Program Counter)**: **指向下一条将要执行的指令**。        |

### 加载/存储 (Load/Store) 架构

这是 RISC 的核心思想。**CPU 不能直接对内存中的数据进行运算**。

1. 必须先用 `LDR` (Load Register) 指令将内存中的数据加载到寄存器中。
2. 在寄存器之间完成所有算术和逻辑运算。
3. 再用 `STR` (Store Register) 指令将结果存回内存。

### 常用指令

- **数据传送**:
- `MOV Rd, Rn`: 将 `Rn` 的值赋给 `Rd`。 (e.g., `MOV R0, R1`)
- **算术运算**:
- `ADD Rd, Rn, Rm`: `Rd = Rn + Rm`

- `SUB Rd, Rn, Rm`: `Rd = Rn - Rm`
- **内存操作**:
- `LDR Rd, [Rn, #offset]`: 从地址 `Rn + offset` 加载一个字到 `Rd`。

- `STR Rd, [Rn, #offset]`: 将 `Rd` 的值存储到一个字到地址 `Rn + offset`。
- **栈操作**:
- `PUSH {reg_list}`: 将寄存器列表压入栈。

- `POP {reg_list}`: 将值从栈中弹出到寄存器列表。
- **跳转与比较**:
- `CMP Rn, Rm`: 比较 `Rn` 和 `Rm`，并设置标志位。

- `B target`: 无条件跳转到 `target`。

- `BEQ target`: 如果相等则跳转。

- `BNE target`: 如果不相等则跳转。

- `BL target`: **(Branch with Link)** "调用函数"。它会**自动将下一条指令的地址存入 LR 寄存器**，然后跳转到 `target`。

- 函数返回时，只需执行 `MOV PC, LR` 或 `BX LR` 即可。

### 调用约定 (AAPCS)

ARM Procedure Call Standard。

- **参数传递**:
- 前 4 个参数通过 **R0, R1, R2, R3** 传递。

- 剩余的参数通过栈传递。
- **返回值**:
- 返回值存储在 **R0** 中。
- **返回地址**:
- 通过 **LR** 寄存器管理。

---

## x86 vs. ARM 核心差异对比

| 特性         | x86 (CISC)                                      | ARM (RISC)                                            |
| :----------- | :---------------------------------------------- | :---------------------------------------------------- |
| **指令集**   | 复杂，长度可变                                  | 精简，长度固定                                        |
| **内存访问** | **可以直接对内存操作** (e.g., `ADD [mem], EAX`) | **加载/存储架构** (必须先 `LDR`，再 `STR`)            |
| **寄存器**   | 较少，且有特定用途                              | 较多，大多为通用寄存器                                |
| **函数调用** | `CALL` 指令压栈 `EIP`                           | `BL` 指令将返回地址存入 `LR` 寄存器                   |
| **参数传递** | 主要通过**栈**                                  | 主要通过**寄存器** (R0-R3)                            |
| **条件执行** | 通过 `CMP` 和 `Jcc` 跳转指令                    | **所有指令都可以是条件执行的** (e.g., `MOVEQ R0, R1`) |
