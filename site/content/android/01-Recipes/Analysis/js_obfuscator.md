---
title: "JavaScript Obfuscator (OB 混淆) 分析"
date: 2025-04-20
type: posts
tags: ["代理池", "逆向分析", "加密分析", "Android", "反混淆"]
weight: 10
---

# JavaScript Obfuscator (OB 混淆) 分析

> **📚 前置知识**
>
> 本配方涉及以下核心技术，建议先阅读相关章节：
>
> - **JavaScript 基础** - 理解 AST、作用域、闭包等概念
> - **浏览器开发者工具** - 使用 Chrome DevTools 进行调试

`javascript-obfuscator` 是一个非常流行和强大的开源工具，用于混淆和保护 JavaScript 代码。它的混淆产物通常被称为"OB 混淆"。OB 混淆通过多种手段的组合，使得代码难以阅读、理解和调试。

## 核心混淆技术

OB 混淆主要依赖于以下几种关键技术：

### 1. 字符串混淆 (String Concealing)

- **字符串数组**：将代码中所有的字符串（特别是敏感信息）提取出来，放入一个或多个巨大的数组中。

- **编码与加密**：这些字符串通常会使用 Base64、RC4 或其他自定义算法进行编码或加密。

- **解码函数**：提供一个或多个解码函数。在代码执行时，通过调用 `decoder("0x1")` 这样的形式来获取原始字符串。

- **数组乱序与自愈**：为了防止静态分析，字符串数组的顺序会在脚本执行初期被动态打乱，解码函数也会随之调整，增加了静态还原的难度。

### 2. 控制流平坦化 (Control Flow Flattening)

这是 OB 混淆最核心、最复杂的特征之一。

- **状态机转换**：将原始代码块（如函数体内的语句）分割成多个小的代码片段，并放入一个巨大的 `while` 循环中的 `switch` 结构里。

- **状态变量**：用一个状态变量（程序计数器）来控制 `switch` 的执行顺序。每个 `case` 执行完毕后，会更新状态变量，决定下一个要执行的 `case`。

- **逻辑打断**：原始线性的代码逻辑被完全打乱，变成了在一个巨大的循环中无序跳转，使得人工跟踪变得极其困难。

### 3. 代码转换与编码 (Code Transformation)

- **变量名混淆 (Identifier Mangling)**：将有意义的变量名、函数名和属性名替换成无意义的短字符，如 `_0xabc123`。

- **数字常量替换**：将代码中的数字常量（如 `123`）替换成十六进制字符串表达式（如 `0x7b`），或者更复杂的表达式，增加阅读难度。

- **代理函数 (Proxy Functions)**：将简单的二元运算（如 `a + b`）或对象属性访问（`obj.prop`）替换成对一个代理函数的调用，例如 `add(a, b)`。这使得批量替换和模式识别变得更加困难。

- **死代码注入 (Dead Code Injection)**：在代码中插入一些永远不会被执行的、但看起来很复杂的逻辑分支（通常与不透明谓词结合），用来迷惑分析者。

### 4. 反调试与反格式化 (Anti-Debugging)

- **`debugger` 语句**：在代码中插入 `debugger;` 语句，并且通常会将其包裹在一个无限循环的函数中。当开发者工具打开时，程序会立即暂停并陷入这个循环，阻碍动态调试。

- **函数重绑定**：通过 `Function.prototype.constructor` 或 `eval` 来执行代码，使得常规的断点难以命中。

- **反格式化**：检测代码是否被美化或格式化，如果发现，则可能进入死循环或执行错误逻辑。

## 分析与反混淆策略

反混淆 OB 代码通常是一个系统性的工程，需要多种工具和技术结合。

### 1. 字符串解密与替换

- **定位解码函数**：找到负责从字符串数组中取值并解密的函数。

- **执行解码逻辑**：
- **动态执行**：在 Node.js 或浏览器环境中，直接调用解码函数，将所有加密的字符串预先解密出来。

- **静态分析**：如果解码算法（如 RC4）比较标准，可以编写脚本静态地解密所有字符串。
- **批量替换**：编写脚本（通常基于 AST），将代码中所有对解码函数的调用 `decoder("0x1")` 替换成其返回的原始字符串 `"original_string"`。

### 2. 控制流平坦化还原

这是最困难的一步，但也是最有价值的一步。

- **AST 分析**：使用 Babel 等工具将代码解析成 AST。

- **定位主循环**：找到包含 `while(true)` 和 `switch` 的巨大循环体。

- **识别状态变量**：找到控制 `switch` 跳转的状态变量和它的初始值。

- **重排代码块**：

1. 提取 `switch` 的 `case` 数组和状态变量的初始跳转顺序。
2. 根据这个顺序，将每个 `case` 块中的代码按正确的逻辑重新排列。
3. 移除 `while` 和 `switch` 结构，生成线性的、可读的代码。

- **自动化工具**：社区中有一些尝试自动化还原控制流的工具，但由于 OB 混淆变种繁多，通用性有限。

### 3. 其他净化操作

- **常量表达式计算**：将 `0x7b` 这样的表达式直接计算成 `123`。

- **代理函数内联**：将代理函数的逻辑直接替换回原来的位置，例如将 `add(a, b)` 还原成 `a + b`。

- **死代码移除**：通过分析控制流，识别并删除无法访问到的代码块。

## 常用工具

- **Babel (核心)**：用于解析（Parse）、转换（Transform）和生成（Generate）JavaScript 代码，是编写反混淆脚本的基础。

- **AST Explorer**：在线查看 AST 结构，便于编写转换逻辑。

- **Node.js / 浏览器控制台**：用于动态执行代码片段，特别是解密函数。

- **de4js**, **js-beautify**：用于基本的代码格式化和一些简单的反混淆。

- **AST-Deobfuscator**：一些开源的、基于 AST 的反混淆工具框架，可以作为参考。
