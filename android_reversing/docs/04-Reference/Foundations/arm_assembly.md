# ARM 汇编入门 (Android Native)

当应用的核心逻辑、加密算法或性能密集型任务用 C/C++ 编写时，它们会被编译成原生库 (`.so` 文件)。在 Android 上，这些库主要是 ARM 架构的。理解 ARM 汇编是分析 `.so` 文件的基础。本指南将介绍逆向工程师需要了解的 ARMv7 (32-bit) 和 ARMv8 (64-bit/A64) 的基础知识。

!!! question "思考：为什么必须学习汇编？"
当你遇到以下场景时，该如何应对？

- 用 Jadx 打开 APK，发现关键的加密逻辑都在 `native` 方法中
- Frida Hook 到了某个 JNI 函数，但参数是指针，不知道如何读取
- IDA 打开 `.so` 文件，满屏的汇编指令让你无从下手

## 这些场景的共同点是：**核心逻辑被编译成了机器码**。不理解汇编，就像试图在不懂外语的情况下阅读外文书籍——你只能靠猜。

## 目录

1. [**基本概念：ARM vs x86**](#基本概念arm-vs-x86)
2. [**寄存器 (Registers)**](#寄存器-registers)

- [ARM 32-bit (ARMv7)](#arm-32-bit-armv7)

- [ARM 64-bit (AArch64)](#arm-64-bit-aarch64)

3. [**核心指令集**](#核心指令集)

- [数据移动指令](#数据移动指令)

- [算术与逻辑指令](#算术与逻辑指令)

- [分支与条件执行指令](#分支与条件执行指令)

- [栈操作指令](#栈操作指令)

4. [**函数调用约定 (Procedure Call Standard)**](#函数调用约定)
5. [**从 C 代码到汇编**](#从-c-代码到汇编)
6. [**IDA Pro/Ghidra 中的视图**](#ida-proghidra-中的视图)

---

### 基本概念：ARM vs x86

- **RISC vs CISC**: ARM 是**精简指令集计算机 (RISC)**，指令长度固定，种类较少，操作简单。x86 是**复杂指令集计算机 (CISC)**。

- **Load/Store 架构**: ARM 是一种"加载/存储"架构。这意味着数据处理（如加法、减法）**只能在寄存器之间**进行。你必须先用加载指令 (`LDR`) 将内存中的数据加载到寄存器，计算完成后再用存储指令 (`STR`) 将结果存回内存。

- **指令模式**: ARMv7 (32-bit) 支持两种指令集：
- **ARM**: 32-bit 定长指令，功能强大。

- **Thumb**: 16-bit/32-bit 变长指令，代码密度更高，是移动设备上的主流。在 IDA 等工具中，你通常会分析 Thumb 模式下的代码。

---

### 寄存器 (Registers)

寄存器是 CPU 内的高速存储单元。

!!! tip "快速定位关键寄存器"
在分析一个陌生函数时，如何快速抓住重点？

- **函数入口**：先看 `R0-R3` (32 位) 或 `X0-X7` (64 位)，这些是参数
- **函数返回**：关注 `R0/X0`，这是返回值存放的地方
- **函数调用**：`BL` 指令前后，检查参数寄存器的变化
- **栈操作**：`SP` 的变化反映了局部变量的分配

这种"重点优先"的阅读策略，能让你快速理解函数的输入输出，而不必逐行分析每条指令。

#### ARM 32-bit (ARMv7)

共有 16 个通用寄存器 (`R0` - `R15`)。

| 寄存器       | 别名        | 用途                                                                                |
| :----------- | :---------- | :---------------------------------------------------------------------------------- |
| `R0` - `R3`  | `A1` - `A4` | **参数寄存器** (Argument)。用于传递函数的前 4 个参数。`R0` 也用作**返回值寄存器**。 |
| `R4` - `R11` | `V1` - `V8` | **变量寄存器** (Variable)。用于保存函数的局部变量。                                 |
| `R12`        | `IP`        | 过程调用间临时寄存器 (Intra-Procedure call scratch register)。                      |
| `R13`        | `SP`        | **栈指针** (Stack Pointer)。指向栈顶。                                              |
| `R14`        | `LR`        | **链接寄存器** (Link Register)。存储函数调用的返回地址。                            |
| `R15`        | `PC`        | **程序计数器** (Program Counter)。指向当前正在执行的指令。                          |

#### ARM 64-bit (AArch64)

寄存器数量更多，且功能更明确。

| 寄存器        | 用途                                                                       |
| :------------ | :------------------------------------------------------------------------- | -------------------------------- |
| `X0` - `X7`   | **参数寄存器**。用于传递函数的前 8 个参数。`X0` 同样用作**返回值寄存器**。 |
| `X8` - `X18`  | 调用者/被调用者保存的临时寄存器。                                          |
| `X19` - `X28` | 被调用者保存的寄存器 (Callee-saved)。                                      |
| `X29`         | `FP`                                                                       | **帧指针** (Frame Pointer)。     |
| `X30`         | `LR`                                                                       | **链接寄存器** (Link Register)。 |
| `SP`          | **栈指针** (Stack Pointer)。                                               |

- 注\*: `W` 寄存器 (`W0`, `W1`...) 是 `X` 寄存器的低 32 位。例如，对 `W0` 的操作就是对 `X0` 的低 32 位进行操作。

---

### 核心指令集

#### 数据移动指令

- `MOV R1, R2` (32-bit) / `MOV X1, X2` (64-bit): 将寄存器 `R2` 的值移动到 `R1`。

- `LDR R0, [SP, #4]` (32-bit) / `LDR X0, [SP, #8]` (64-bit): **加载**。从栈指针 `SP` 偏移 4 (或 8) 字节的位置读取数据，并存入 `R0` (或 `X0`)。

- `STR R0, [SP, #4]` (32-bit) / `STR X0, [SP, #8]` (64-bit): **存储**。将 `R0` (或 `X0`) 的值写入到 `SP` 偏移 4 (或 8) 字节的内存地址。

- `ADR X0, aHelloWorld` (64-bit, PC-relative): `ADR` (Address PC-Relative) 指令将一个相对于 PC 的地址（如字符串 "Hello World" 的地址）加载到 `X0`。

#### 算术与逻辑指令

- `ADD R0, R1, R2`: `R0 = R1 + R2`。

- `SUB R0, R1, #1`: `R0 = R1 - 1`。

- `and R0, R0, #0xFF`: 按位与。

- `CMP R0, #10`: **比较** `R0` 和 10。该指令会更新状态寄存器 (CPSR)，但不存储结果。它总是紧跟在条件分支指令之前。

#### 分支与条件执行指令

- `B label`: **分支** (Branch)。无条件跳转到 `label`。

- `BL label`: **带链接的分支** (Branch with Link)。跳转到 `label` 之前，将下一条指令的地址存入 `LR` (链接寄存器)。这是**函数调用**的核心指令。

- `BX LR` / `RET`: **带交换的分支** (Branch with Exchange) / **返回**。跳转到 `LR` 中的地址，实现函数返回。`RET` 是 `BX LR` 的别名。

- `B.EQ label`: **条件分支**。如果前一个 `CMP` 指令的结果是相等 (Equal)，则跳转。

- `B.NE label`: 不相等 (Not Equal)。

- `B.GT label`: 大于 (Greater Than)。

- `B.LT label`: 小于 (Less Than)。

- `B.GE label`: 大于或等于 (Greater or Equal)。

- `B.LE label`: 小于或等于 (Less or Equal)。

#### 栈操作指令

- `PUSH {R4, LR}`: 将 `R4` 和 `LR` 寄存器压入栈。通常在函数开头，用于保存需要使用的寄存器和返回地址。

- `POP {R4, PC}`: 将栈顶数据弹出到 `R4` 和 `PC`。`POP {..., PC}` 是一种常见的函数返回方式，它将保存在栈上的 `LR` 值直接弹出到 `PC`，实现了跳转返回。

- `STP X29, X30, [SP, #-16]!` (A64): `STP` (Store Pair) 指令，将一对寄存器 (`X29`/`FP`, `X30`/`LR`) 存入 `SP` 指向的地址，`!` 表示 `SP` 会预先减去 16。

- `LDP X29, X30, [SP], #16` (A64): `LDP` (Load Pair) 指令，从 `SP` 地址加载数据到 `X29` 和 `X30`，然后 `SP` 再增加 16。

---

### 函数调用约定 (Procedure Call Standard)

1. **参数传递**:

- **32-bit**: 前 4 个参数通过 `R0` - `R3` 传递。

- **64-bit**: 前 8 个参数通过 `X0` - `X7` 传递。

- 超出数量的参数通过**栈**传递。

2. **函数调用**: 调用者使用 `BL` 指令。
3. **函数序言 (Prologue)**:

- 被调用函数（子函数）首先要做的是保存现场。

- 使用 `PUSH` 或 `STP` 将需要在函数中使用的寄存器（如 `R4-R11`, `FP`, `LR`) 压入栈中。

- 分配栈空间给局部变量 (`SUB SP, SP, #...`)。

4. **函数结语 (Epilogue)**:

- 函数执行完毕，准备返回。

- 释放局部变量的栈空间 (`ADD SP, SP, #...`)。

- 使用 `POP` 或 `LDP` 从栈中恢复之前保存的寄存器。

- 使用 `BX LR` 或 `RET` 或 `POP {PC}` 返回。

5. **返回值**:

- 简单的返回值（整数、指针）存放在 `R0` (32-bit) 或 `X0` (64-bit) 中。

---

### 从 C 代码到汇编

**C 代码:**

```c
int add_one(int a) {
return a + 1;
}

```

BX LR ; return

```
RET ; return

```

- **伪代码视图 (Pseudocode View)**: IDA Pro (F5 键) 和 Ghidra 的反编译器可以直接将汇编代码转换成可读性很高的 C 伪代码，这是静态分析的利器。通常先看伪代码，遇到不理解的地方再回头看汇编。
