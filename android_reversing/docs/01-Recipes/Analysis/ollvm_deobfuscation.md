# OLLVM 反混淆

OLLVM (Obfuscator-LLVM) 是一个著名的开源代码混淆框架，它在 LLVM 编译器 IR (中间表示) 层面进行操作。这使其能够与具体语言无关，并对代码应用复杂的、难以逆向的转换。

!!! warning "场景导入：当你遇到 OLLVM"
打开 IDA，反编译一个函数，结果看到：

- 一个巨大的 `switch-case` 循环，有几十甚至上百个 case 分支
- 每个 case 里只有几行代码，然后又跳回 switch
- 到处都是看起来有用实际无用的 `if` 判断
- 简单的加法被替换成了 `a = b - (-c)` 这样的怪异表达式

**你的第一反应可能是：这是什么鬼？**

恭喜，你遇到了 OLLVM 控制流平坦化 (FLA) + 虚假控制流 (BCF) + 指令替换 (SUB) 的"三件套"。
这是目前 Android Native 层最常见的商业级混淆方案。

**关键问题**：面对这种混淆，是选择"硬看"代码，还是有更聪明的办法？

本文档涵盖了常见的 OLLVM 混淆通道 (pass) 及其分析和逆向策略。

---

## 核心混淆技术

OLLVM 的主要优势在于其三种核心混淆技术：

1. **控制流平坦化 (`-fla`)**: 该技术会彻底平坦化一个函数的控制流。它通过将所有基本块放入一个单一的、巨大的分发器循环（"主分发器"）中来隐藏原始的程序流程。一个状态变量用于控制下一个要执行的代码块。逆向此技术需要重建原始的控制流图 (CFG)。

2. **虚假控制流 (`-bcf`)**: 该技术在代码中插入无效的条件分支和不透明谓词。这些分支被设计为静态分析难以解析，但在运行时，它们总是会得出相同的结果。这会给控制流图增加大量的噪声。

3. **指令替换 (`-sub`)**: 这是最简单的混淆方式。它将标准的二进制运算符（如 `add`, `sub`, `and`, `or`）替换为功能上等价但更复杂的指令序列。例如，`a = b + c` 可能会变成 `a = b - (-c)`。

---

## 分析与反混淆策略

!!! question "思考：静态分析 vs 动态分析，哪个更有效？"
面对 OLLVM 混淆，有两种完全不同的思路：

**静态分析**：

- ✅ 优势：能看到所有可能的执行路径，包括错误处理分支
- ❌ 劣势：需要对抗大量的虚假分支，分析工作量巨大
- 适用场景：你需要理解完整的算法逻辑，或者寻找漏洞

**动态分析**：

- ✅ 优势：直接记录真实执行路径，绕过所有虚假分支
- ❌ 劣势：只能看到当前输入下的执行路径，可能遗漏关键分支
- 适用场景：你只想提取算法结果（如加密签名），不关心内部逻辑

**实战建议**：

1. 先用动态分析（Frida Stalker / Unidbg trace）快速获取"真实"的执行流
2. 再用静态分析验证和补充动态分析遗漏的部分
3. 如果目标是自动化（如算法还原），考虑符号执行（Angr）

### 1. 静态分析

- **CFG 重建**: 对于控制流平坦化，关键是识别状态变量和分发器。通过符号执行或模式匹配分发器逻辑，可以确定每个真实基本块的后继，从而重建原始图。

- **不透明谓词求解**: Z3 或其他 SMT 求解器等工具可用于自动证明虚假控制流中的条件是不变的。这使得分析师能够识别并移除无效的代码路径。

- **模式匹配**: 对于指令替换，可以识别并替换简单的模式。例如，像 `x = rdtsc(); y = x & 1; if (y == 0) ...` 这样的序列是一个常见的虚假谓词。

### 2. 动态分析

- **使用 Frida/Unidbg 进行追踪**: 动态追踪非常有效。通过使用 Frida 的 `Stalker` 或 Unidbg 的追踪功能，可以记录运行时执行的基本块的确切顺序。这可以绕过所有的控制流混淆，为你提供"真实"的执行路径。

- **符号执行**: 像 Angr 这样的引擎可用于探索程序状态。符号执行可以自动求解路径约束，从而有效地反混淆控制流并简化不透明谓词。这个过程可能很慢，但功能非常强大。

### 3. 自动化工具

- **d-obfuscator**: 一个基于 Python 的工具，使用符号执行（通过 Angr）来反混淆 OLLVM。

- **QB-Di**: 一个基于 QBDI 动态插桩框架的交互式反混淆工具。

- **Triton**: 一个动态二进制分析框架，可以通过编写脚本来执行污点分析和符号执行。
