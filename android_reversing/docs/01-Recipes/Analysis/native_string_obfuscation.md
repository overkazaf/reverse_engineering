# Native 层字符串混淆与逆向

在 Android Native 开发（C/C++）中，直接将明文字符串硬编码在代码中会带来安全风险。静态分析工具（如 IDA Pro、Ghidra）可以轻易地在二进制文件的 `.rodata`（只读数据）段中找到这些字符串，从而泄露 API 地址、加密密钥、敏感校验逻辑等信息。因此，开发者通常会采用各种字符串混淆技术来保护这些数据。

## 常见的 Native 字符串混淆技术

### 1. 栈上动态构造 (Stack-based Construction)

这是最简单的一种方法。它避免在数据段中留下完整的字符串，而是在函数运行时，逐个字符地将字符串构造在栈上。

**示例代码:**

```cpp
void get_secret_url() {
char url[19];
url[0] = 'h'; url[1] = 't'; url[2] = 't'; url[3] = 'p';
url[4] = 's'; url[5] = ':'; url[6] = '/'; url[7] = '/';
url[8] = 'a'; url[9] = 'p'; url[10] = 'i'; url[11] = '.';
url[12] = 'e'; url[13] = 'x'; url[14] = 'a'; url[15] = 'm';
url[16] = 'p'; url[17] = 'l'; url[18] = 'e';
url[19] = '\0'; // Null terminator
// ... use url
}

```

**示例代码:**

```cpp
char* decrypt_string(char* encrypted) {
char key = 0xAB;
int len = strlen(encrypted);
for (int i = 0; i < len; i++) {
encrypted[i] = encrypted[i] ^ key;
}
return encrypted;
}

void use_secret() {
// "secret_key" Xored with 0xAB
char encrypted_key[] = { 0xCF, 0xC4, 0xC2, 0xCD, 0xC4, 0xD1, 0xDF, 0xCB, 0xC4, 0xD8, 0x00 };
char* secret = decrypt_string(encrypted_key);
// ... use secret
}

```

**优点**: 自动化、全局覆盖、对开发者透明。
**缺点**: 通常需要定制的编译器或工具链。

## 逆向策略

逆向字符串混淆的目标是 **批量地、自动化地** 将混淆的字符串还原出来。

### 1. 静态分析 (IDA Pro / Ghidra)

静态分析是识别解密例程（Decryption Routine）和批量解密的关键。

- **识别解密模式**:
- 寻找特征性的循环结构。一个循环遍历内存、执行固定操作（如 `XOR`）然后写回，这通常就是解密函数。

- 在 IDA Pro 中，这种循环的图形视图非常具有辨识度。
- **定位解密函数**:
- 通过交叉引用（Xrefs）找到加密数据被哪些函数使用。这些函数很可能就是解密函数。

- 一旦找到一个解密函数，分析其逻辑（输入、输出、加密算法）。
- **自动化解密 (IDAPython / Ghidra Script)**:

1. **编写脚本**: 这是最高效的方法。编写一个脚本来模拟解密逻辑。
2. **寻找引用**: 脚本首先找到所有对解密函数的交叉引用。
3. **提取参数**: 在每个调用点，脚本向上回溯，解析传递给解密函数的参数（加密的数据、密钥等）。
4. **执行解密**: 脚本在内部执行解密算法。
5. **添加注释**: 最后，将解密后的字符串作为注释添加到 IDA Pro 或 Ghidra 的反汇编代码中。

### 2. 动态分析 (Frida)

当静态分析过于复杂或存在反调试时，动态分析是最佳选择。

- **Hook 解密函数**:

1. 通过初步的静态分析定位到疑似的解密函数。
2. 使用 Frida `Interceptor.attach` 来 Hook 这个函数的入口和出口。
3. 在 `onEnter` 中，打印函数的参数（通常是指向加密数据的指针）。
4. 在 `onLeave` 中，打印函数的返回值（通常是指向已解密的明文字符串的指针）。
5. 通过运行 App 并触发不同功能，就可以从日志中收集到大量的明文字符串。

- **内存扫描**:
- 另一种策略是让应用运行一段时间，然后使用 Frida 脚本或 GameGuardian 等工具扫描整个进程内存，寻找符合字符串特征（如 ASCII、UTF-8）的内存区域。

- **优点**: 无需关心解密逻辑。

- **缺点**: 信息非常嘈杂，包含大量无用数据；无法将被加密存储但在运行时未被使用的字符串解密出来。

### 3. 模拟执行 (Emulation)

对于一些独立的、没有太多外部依赖的解密函数，可以使用模拟执行框架（如 `Unicorn Engine`）来解密。

1. **提取代码和数据**: 从二进制文件中 dump 出解密函数的机器码和需要解密的字节数组。
2. **设置环境**: 在 Unicorn 中，映射所需的内存区域，将加密数据放入。
3. **模拟执行**: 设置好初始寄存器状态（如参数指针），然后开始模拟执行解密函数的机器码。
4. **获取结果**: 执行完毕后，从内存中读回解密后的字符串。

**优点**: 速度比动态分析快，无需运行完整的 App，可绕过反调试。
**缺点**: 环境设置复杂，不适用于有大量系统调用或复杂依赖的函数。
