# 验证码绕过技术：滑块与点选篇

> **📚 前置知识**
>
> 本配方涉及以下核心技术，建议先阅读相关章节：
>
> - **[网络抓包技术](../Network/network_sniffing.md)** - 分析验证码请求与响应
> - **Python 自动化** - 使用 Selenium/Playwright 模拟浏览器行为

滑块和点选（或称图标）验证码是现代 Web 应用中用于区分人类用户和自动化程序（机器人）的常见手段。与传统的字符输入验证码相比，它们更注重于分析用户的"行为特征"。本文旨在详细介绍绕过这两类验证码的主流技术和核心思想。

---

## 目录

- [验证码绕过技术：滑块与点选篇](#验证码绕过技术滑块与点选篇)
  - [目录](#目录)
    - [验证码核心机制](#验证码核心机制)
      - [滑块验证码](#滑块验证码)
      - [点选验证码](#点选验证码)
    - [绕过策略一：模拟人类行为](#绕过策略一模拟人类行为)
      - [步骤 1: 目标识别 (计算机视觉)](#步骤-1-目标识别-计算机视觉)
      - [步骤 2: 轨迹模拟 (核心关键)](#步骤-2-轨迹模拟-核心关键)
      - [第三方打码平台](#第三方打码平台)
    - [绕过策略三：寻找逻辑漏洞](#绕过策略三寻找逻辑漏洞)
    - [防御与对抗的演进](#防御与对抗的演进)

---

### 验证码核心机制

#### 滑块验证码

- **目标**: 用户需要将滑块拖动到背景图的缺口位置。

- **验证重点**:

1. **结果准确性**: 滑块最终停留的位置是否在缺口的目标容差范围内。
2. **行为可信度**: **(更重要)** 用户的鼠标轨迹是否像人。一个由程序生成的、匀速的、完美的直线轨迹几乎肯定会被判定为机器人。

#### 点选验证码

- **目标**: 根据提示，按顺序点击图片中的一个或多个汉字、图标或物体。

- **验证重点**:

1. **识别准确性**: 是否能正确识别并点击目标。
2. **行为可信度**: 点击的坐标、间隔时间、鼠标移动轨迹是否自然。

---

### 绕过策略一：模拟人类行为

这是最主流、最根本的绕过方法，其核心是尽可能地模仿人类操作的不完美性。

#### 步骤 1: 目标识别 (计算机视觉)

在模拟操作之前，程序需要先像人一样"看懂"验证码。

- **对于滑块验证码 (缺口识别)**:
- **常用库**: OpenCV (Python)。

- **方法一：边缘检测**:
    1. 获取带缺口的背景图和不带缺口的完整背景图（通常可以从网络请求中找到）。
    2. 使用 Canny 等边缘检测算法分别处理两张图片。
    3. 对比两张图的边缘差异，差异最显著的区域就是缺口的位置。
- **方法二：模板匹配**:
    1. 从网络请求或页面元素中获取到独立的"滑块"图片。
    2. 将滑块图片作为"模板"，在带缺口的背景图上进行模板匹配 (`cv2.matchTemplate`)。匹配度最高的地方就是缺口的起始 X 坐标。

- **对于点选验证码 (目标识别)**:
- 如果目标是固定的文字或图标，可以采用与滑块类似的**模板匹配**方法。

- 如果目标是变化的、复杂的，例如"请点击图中所有的公交车"，则需要依赖更高级的机器学习模型（见策略二）。

#### 步骤 2: 轨迹模拟 (核心关键)

这是整个绕过过程的灵魂。一个好的轨迹模拟算法需要考虑以下几点，以欺骗服务器端的行为分析模型：

- **非线性移动**: 绝对不能是 `(x1, y1)` 到 `(x2, y2)` 的直线。路径需要是带有弧度的曲线。

- **变速移动**: 模拟人类操作的肌肉控制，轨迹应该是"慢-快-慢"的模式。
- **初段加速**: 初始移动速度较慢。

- **中段匀速/加速**: 中间过程速度加快。

- **末段减速**: 接近目标时，速度会显著减慢，进行微调。
- **随机抖动**: 在主轨迹的基础上，叠加微小的、随机的 Y 轴（有时也包括 X 轴）偏移，模拟手部自然的抖动。

- **超越与回退**: 有时可以模拟"拖过头了一点点，再往回拉"的行为，这会极大地增加轨迹的可信度。

- **停顿**: 在拖动过程中可以加入短暂的、随机时长的停顿。

- **实现示例 (伪代码)**:

```python
def generate_human_like_track(target_distance):
track = []
current_pos = 0
# Movement pattern: accelerate first, then decelerate
while current_pos < target_distance:
# 1. Calculate movement step size for current phase (non-uniform speed)
if current_pos < target_distance * 0.7:
step = random.uniform(2, 4) # Acceleration phase
else:
step = random.uniform(0.5, 2) # Deceleration and fine-tuning phase

# 2. Add random jitter
y_offset = random.uniform(-1, 1)

# 3. Record trajectory point
track.append((step, y_offset, random.uniform(10, 50))) # (x step, y offset, time interval ms)
current_pos += step

# (Optional) Add "overshoot and pull back" trajectory points
# ...
return track

```

- **适用场景**: 需要从一张大图中识别并定位多个不规则物体的点选验证码（例如，"选出所有的红绿灯"）。

- **方法**:

1. **数据标注**: 收集大量的验证码图片，并手动标注出需要识别的物体（如"红绿灯"、"公交车"）。
2. **模型训练**: 使用标注好的数据集训练一个目标检测模型，如 YOLOv5 或 SSD。
3. **推理**: 在实际绕过时，将验证码图片输入到训练好的模型中，模型会返回所有识别到的目标的位置坐标。
4. **后续操作**: 拿到坐标后，再结合上一节的"轨迹模拟"方法去点击。

#### 第三方打码平台

- **概念**: 将识别验证码这一专业任务外包给第三方服务。这些平台背后通常是大量的人工或者更强大的 AI 模型。

- **代表服务**: 2Captcha, Anti-Captcha 等。

- **工作流程**:

1. 注册并充值。
2. 通过 API 将验证码图片（或任务描述）发送给平台。
3. 平台返回结果（如滑块的 X 坐标，或点选目标的坐标序列）。
4. 你的程序拿到结果后，再执行后续的模拟操作。

- **优点**: 成功率极高，能解决几乎所有类型的验证码，无需自己维护复杂的识别模型。

- **缺点**: 需要付费，存在隐私和安全风险（将数据发给第三方），有网络延迟。

---

### 绕过策略三：寻找逻辑漏洞

在投入大量精力编写复杂的模拟和识别代码前，先尝试寻找"捷径"是一种高性价比的策略。

- **分析前端 JS**: 仔细审查页面的 JavaScript 文件，特别是与验证码相关的逻辑。有时可能会发现：
- **答案硬编码或弱加密**: 缺口位置、目标坐标等信息以明文或简单加密的方式存在于前端代码中。

- **可预测的随机数**: 用于生成验证码的随机种子或算法过于简单，可以被预测。
- **API 漏洞**:
- **验证绕过**: 尝试直接调用提交表单的 API，但不带验证码相关的参数，看后端是否强制校验。

- **Token 重放**: 成功通过一次验证后，获取到的 `session_token` 或 `captcha_id` 是否可以被多次重用。

---

### 防御与对抗的演进

验证码提供商也在不断进化，以对抗上述绕过技术：

- **环境检测**: 检测 WebDriver 特征（如 `navigator.webdriver` 标志）、浏览器指纹、字体、分辨率等。

- **更复杂的行为分析**: 不仅仅是轨迹，还会分析点击压力、滚轮行为、鼠标加速度等更深层次的生物特征。

- **图像干扰**: 在验证码图片上增加干扰线、噪点、形变、颜色抖动，增加 CV 识别难度。

- **无感验证 (reCAPTCHA v3)**: 完全在后台根据用户的综合行为评分，分数过低时才弹出挑战。
