# 移动端安全与风控技术

现代移动应用，特别是那些处理敏感用户数据或有价值业务逻辑的应用，通常会实现多层安全机制来防御逆向工程、篡改和自动化滥用（机器人）。这一领域通常被称为"RASP"（运行时应用自我保护）或"反机器人技术"。

本文档概述了常见的技术。

---

## 关键防御类型

### 1. 反调试与反分析

这些技术旨在检测并阻止像调试器和插桩框架这样的分析工具。

- **调试器检测**:
- 检查 `/proc/self/status` 中的 `TracerPid`。一个非零值表示有调试器附加。

- 使用 `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` 并检查返回值是否小于 0。

- 时间检查：测量执行一段代码所需的时间。如果附加了调试器（带有断点），时间将会有显著不同。
- **Frida 检测**:
- 扫描内存中是否存在 `frida-agent` 或 `frida-gadget` 库。

- 通过尝试连接其默认端口（27042）来检测 Frida 的服务器。

- 检查 Frida 特有的痕迹，如命名管道（`frida-pipe`）或对 `REPL` 环境的修改。
- **模拟器/Root 检测**:
- 检查已知的模拟器特有文件、属性（`ro.kernel.qemu`）或设备驱动。

- 检查是否存在 root 管理应用（如 SuperSU）或 `su` 二进制文件。

### 2. 反篡改

这些技术确保应用的代码和数据未被修改。

- **代码完整性校验**: 在运行时计算 `classes.dex` 文件或原生库（`.so`）的校验和或哈希值（例如 SHA-256），并与安全存储的已知良好值进行比较。

- **签名验证**: 在运行时，获取应用自身的签名并验证其是否与官方开发者签名匹配。这可以防止重打包。

- **内存完整性校验**: 定期扫描应用自身的内存，以确保关键函数未被 Frida 等工具钩住或修补。

### 3. 反机器人与业务逻辑保护

这些技术旨在防止自动化脚本滥用应用的 API 或功能（例如，创建垃圾账户、抓取数据）。

- **设备证明**: 使用像 Android 的 `SafetyNet` / `Play Integrity` API 这样的服务，从谷歌服务器获取一个加密证明，证明设备是真实的、非 root 的，并且正在运行官方应用。这非常难以绕过。

- **请求签名**: 关键的 API 请求通常受"签名"保护。这个签名是根据请求参数、时间戳、随机数和一个密钥计算出的哈希值（例如 HMAC-SHA256）。密钥通常使用混淆等技术隐藏起来。逆向这个签名算法是分析师的一个常见目标。

- **行为分析**: 在服务器端，分析 API 调用的*时间*和*顺序*，以建立真实用户的行为画像。机器人通常具有非常僵硬、非人类的时间模式，可以用来检测它们。

---

## 绕过策略

绕过这些防御需要结合静态和动态分析。

- **钩子与补丁**: 使用 Frida 钩住负责这些检查的函数，并强制它们返回一个"安全"的值。例如，钩住读取 `TracerPid` 的函数，使其总是返回 0。

- **自定义 Frida 版本**: 为了对抗 Frida 检测，你可以编译一个自定义名称和不同默认端口的 `frida-server` 版本。

- **静态分析**: 反汇编应用以找到检查逻辑。一旦找到，你通常可以将其"nop"掉（用 `NOP` 指令替换），以永久禁用它。
