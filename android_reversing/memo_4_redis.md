# 🚀 Redis 内存数据库速记

## 📊 基础数据结构

### 🔤 核心数据类型

| 数据类型 | 说明 | 常用场景 | 时间复杂度 |
|:---|:---|:---|:---|
| **String** | 二进制安全字符串 | 缓存、计数器、分布式锁 | O(1) |
| **Hash** | 键值对映射表 | 对象存储、用户信息 | O(1) |
| **List** | 双向链表 | 消息队列、任务列表 | O(1) |
| **Set** | 无序唯一集合 | 标签、去重、交集 | O(1) |
| **Sorted Set** | 有序唯一集合 | 排行榜、范围查询 | O(log N) |

### 🔧 常用命令速查

#### String 操作
```redis
SET key value          # 设置值
GET key                # 获取值
INCR key               # 自增1
INCRBY key increment   # 自增指定值
EXPIRE key seconds     # 设置过期时间
```

#### Hash 操作
```redis
HSET key field value   # 设置字段值
HGET key field         # 获取字段值
HGETALL key           # 获取所有字段
HDEL key field        # 删除字段
```

#### List 操作
```redis
LPUSH key value       # 左侧插入
RPUSH key value       # 右侧插入
LPOP key              # 左侧弹出
RPOP key              # 右侧弹出
LRANGE key start stop # 范围查询
```

---

## 🏗️ 架构与部署模式

### 📋 部署架构对比

| 模式 | 优点 | 缺点 | 适用场景 |
|:---|:---|:---|:---|
| **单机模式** | 简单、一致性强 | 单点故障、性能受限 | 开发测试、小型应用 |
| **主从复制** | 读写分离、备份 | 手动故障转移 | 读多写少场景 |
| **Sentinel** | 自动故障转移 | 配置复杂、写性能受限 | 高可用要求 |
| **Cluster** | 水平扩展、高性能 | 复杂度高、部分限制 | 大数据量、高并发 |

### 🔄 主从复制原理
```
Master (写)  →  Replica1 (读)
    ↓      →  Replica2 (读)
    ↓      →  Replica3 (读)
   全量同步 + 增量同步
```

### 🛡️ Sentinel 高可用
- **监控**: 监控主从节点健康状态
- **通知**: 故障时发送通知
- **故障转移**: 自动选举新的主节点
- **配置提供**: 为客户端提供服务发现

---

## 💾 持久化机制

### 📊 持久化方式对比

| 方式 | 原理 | 优点 | 缺点 |
|:---|:---|:---|:---|
| **RDB** | 快照备份 | 文件小、恢复快 | 数据丢失风险 |
| **AOF** | 命令日志 | 数据安全性高 | 文件大、恢复慢 |
| **混合持久化** | RDB + AOF | 兼顾性能与安全 | 复杂度增加 |

### ⚙️ 配置参数
```conf
# RDB配置
save 900 1        # 900秒内至少1个key变化时保存
save 300 10       # 300秒内至少10个key变化时保存

# AOF配置  
appendonly yes
appendfsync everysec  # 每秒同步一次
```

---

## 🧠 内存管理与优化

### 📈 内存淘汰策略

| 策略 | 说明 | 适用场景 |
|:---|:---|:---|
| **noeviction** | 不淘汰，返回错误 | 严格的数据完整性要求 |
| **allkeys-lru** | 所有key中淘汰最近最少使用 | 通用缓存场景 |
| **volatile-lru** | 设置过期时间的key中LRU | 部分数据持久化 |
| **allkeys-random** | 随机淘汰任意key | 均匀访问模式 |
| **volatile-ttl** | 优先淘汰即将过期的key | 基于过期时间的策略 |

### 🔧 性能优化技巧
- **合理设置过期时间**: 避免大量key同时过期
- **使用Pipeline**: 批量执行命令减少网络开销
- **选择合适的数据结构**: 根据场景选择最优类型
- **监控内存使用**: 设置内存上限和淘汰策略

---

## 🌟 高级特性

### 🔍 布隆过滤器 (Bloom Filter)
**原理**: 使用多个哈希函数映射到位数组，判断元素可能存在
**优点**: 空间效率高、查询速度快
**缺点**: 存在误判（假阳性）、无法删除元素

```redis
# Redis模块命令
BF.ADD bloom_key item     # 添加元素
BF.EXISTS bloom_key item  # 检查元素是否存在
```

### 📊 Stream 流数据
**特点**: 
- 支持消息持久化
- 自动生成唯一ID
- 支持消费者组
- 提供消息确认机制

```redis
XADD stream_key * field1 value1 field2 value2  # 添加消息
XREAD STREAMS stream_key 0                      # 读取消息
XGROUP CREATE stream_key group_name 0           # 创建消费者组
```

### 🔐 分布式锁实现
```redis
# 获取锁
SET lock_key unique_value PX 30000 NX

# 释放锁 (Lua脚本保证原子性)
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
```

---

## 🛡️ 脑裂问题与解决方案

### ❗ 脑裂现象
**定义**: 在分布式系统中，由于网络分区导致多个节点都认为自己是主节点的情况。

**Redis中的脑裂场景**:
```
原Master (写入继续) ←→ 网络分区 ←→ Sentinel + Slaves (选举新Master)
```

### 🔧 脑裂危害
- **数据不一致**: 两个Master同时接受写入
- **数据丢失**: 网络恢复后原Master数据可能丢失
- **服务混乱**: 客户端不知道连接哪个Master

### 🛡️ 防脑裂配置
```conf
# 主节点配置
min-slaves-to-write 1        # 至少有1个slave连接才允许写入
min-slaves-max-lag 10        # slave延迟不超过10秒

# 这两个配置组合使用，当主节点失去与slave的连接时
# 会拒绝写操作，避免脑裂时的数据不一致
```

### 🔄 脑裂解决流程
1. **检测**: Sentinel检测到主节点不可达
2. **选举**: 在slave中选举新的主节点
3. **切换**: 客户端重定向到新主节点
4. **恢复**: 原主节点恢复后降级为slave

---

## 🎯 常见面试题及答案

### Q1: Redis 为什么这么快？
**A**: 
1. **内存存储**: 数据存储在内存中，避免磁盘I/O
2. **单线程模型**: 避免线程切换和锁竞争开销
3. **高效数据结构**: 针对不同场景优化的数据结构
4. **I/O多路复用**: epoll/kqueue 高效处理网络请求

### Q2: Redis 单线程为什么还能支持高并发？
**A**: 
- **CPU不是瓶颈**: 内存操作速度快，CPU利用率不高
- **I/O多路复用**: 一个线程处理多个网络连接
- **非阻塞I/O**: 避免等待网络I/O时的线程阻塞
- **简单高效**: 无需考虑线程安全问题

### Q3: Redis 持久化方式的选择策略？
**A**: 
- **RDB适用**: 对数据完整性要求不高，注重性能
- **AOF适用**: 对数据安全性要求高，可容忍较低性能
- **混合模式**: 平衡安全性和性能，推荐生产环境使用

### Q4: 如何解决 Redis 缓存雪崩、穿透、击穿？
**A**: 
- **缓存雪崩**: 设置随机过期时间、多级缓存、限流降级
- **缓存穿透**: 布隆过滤器、空值缓存、参数校验
- **缓存击穿**: 分布式锁、热点数据预加载、降级处理

### Q5: Redis 集群如何实现数据分片？
**A**: 
- **哈希槽**: 16384个槽位，键通过CRC16算法映射到槽位
- **节点分配**: 每个主节点负责一部分槽位
- **数据迁移**: 槽位可在节点间迁移实现扩缩容
- **客户端重定向**: MOVED和ASK重定向机制

### Q6: 什么是Redis的脑裂问题？如何避免？
**A**: 脑裂是指网络分区导致多个主节点同时存在。避免方法：
- 配置 `min-slaves-to-write` 和 `min-slaves-max-lag`
- 使用Sentinel实现自动故障转移
- 客户端正确处理重定向
- 网络分区恢复后的数据同步机制

### Q7: 布隆过滤器在Redis中的应用场景？
**A**: 
- **缓存穿透防护**: 快速判断key是否可能存在
- **爬虫URL去重**: 大规模URL去重场景
- **用户推荐系统**: 避免推荐重复内容
- **黑名单过滤**: 快速检测恶意请求

### Q8: Redis Stream 相比传统消息队列的优势？
**A**: 
- **持久化**: 消息持久化存储，重启不丢失
- **消费者组**: 支持多消费者协作处理
- **消息确认**: 提供ACK机制确保消息处理
- **历史回溯**: 可重复消费历史消息
- **原生支持**: 无需额外组件，简化架构

### Q9: 如何设计一个基于Redis的分布式锁？
**A**: 
```
1. 获取锁: SET lock_key random_value PX 30000 NX
2. 业务处理: 执行临界区代码
3. 释放锁: Lua脚本原子性检查并删除
4. 超时机制: 设置锁过期时间防止死锁
5. 重入支持: 使用ThreadLocal记录重入次数
```

### Q10: Redis 在分布式系统中的最佳实践？
**A**: 
- **高可用**: 使用Sentinel或Cluster模式
- **数据备份**: 定期备份RDB文件
- **监控告警**: 监控内存、连接数、慢查询
- **安全措施**: 设置密码、绑定IP、关闭危险命令
- **版本管理**: 选择稳定版本，谨慎升级