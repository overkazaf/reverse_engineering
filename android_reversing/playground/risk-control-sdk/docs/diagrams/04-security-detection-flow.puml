@startuml Security_Detection_Flow
!theme vibrant
title RiskControl SDK - 安全检测流程

skinparam backgroundColor White
skinparam shadowing false

start

:应用调用 performSecurityCheck();

partition "检测环境初始化" {
    :初始化检测参数;
    :设置检测超时时间;
    :创建结果存储结构;
}

partition "反调试检测" {
    fork
        :TracerPid检测;
        note left
          检查 /proc/self/status
          寻找 TracerPid 非零值
        end note
        
        if (发现调试器?) then (是)
            :记录威胁: DEBUGGER_DETECTED;
            :设置调试标志: true;
        else (否)
            :调试检测通过;
        endif
        
    fork again
        :ptrace自保护;
        note right
          调用 ptrace(PTRACE_TRACEME)
          防止其他进程附加
        end note
        
        if (ptrace调用失败?) then (是)
            :记录威胁: PTRACE_BLOCKED;
            :可能被调试器占用;
        else (否)
            :ptrace保护启用;
        endif
        
    fork again
        :调试端口检测;
        note left
          检查 JDWP 端口
          检查 gdbserver 进程
        end note
        
        if (发现调试端口?) then (是)
            :记录威胁: DEBUG_PORT_OPEN;
        else (否)
            :端口检测通过;
        endif
        
    end fork
}

partition "模拟器检测" {
    fork
        :系统属性检测;
        note right
          • ro.kernel.qemu
          • ro.hardware
          • ro.product.model
          • init.svc.qemud
        end note
        
        :检查模拟器特征属性;
        if (发现模拟器属性?) then (是)
            :记录威胁: EMULATOR_PROPERTIES;
        else (否)
            :属性检测通过;
        endif
        
    fork again
        :文件系统检测;
        note left
          • /system/lib/libc_malloc_debug_qemu.so
          • /sys/qemu_trace
          • /system/bin/qemu-props
        end note
        
        :检查模拟器特征文件;
        if (发现模拟器文件?) then (是)
            :记录威胁: EMULATOR_FILES;
        else (否)
            :文件检测通过;
        endif
        
    fork again
        :硬件特征检测;
        note right
          • CPU型号检测
          • 传感器数量检测
          • 电池状态检测
        end note
        
        :分析硬件指纹;
        if (硬件指纹异常?) then (是)
            :记录威胁: EMULATOR_HARDWARE;
        else (否)
            :硬件检测通过;
        endif
        
    end fork
}

partition "Root检测" {
    fork
        :Su二进制检测;
        note left
          • /system/bin/su
          • /system/xbin/su
          • /sbin/su
          • /data/local/bin/su
        end note
        
        :检查su文件是否存在;
        if (发现su文件?) then (是)
            :记录威胁: ROOT_SU_BINARY;
        else (否)
            :su检测通过;
        endif
        
    fork again
        :Root管理应用检测;
        note right
          • com.noshufou.superuser
          • com.thirdparty.superuser
          • eu.chainfire.supersu
          • com.koushikdutta.superuser
        end note
        
        :检查Root管理包;
        if (发现Root应用?) then (是)
            :记录威胁: ROOT_MANAGEMENT_APP;
        else (否)
            :应用检测通过;
        endif
        
    fork again
        :系统文件写入测试;
        note left
          尝试在系统目录创建文件
          测试是否具有Root权限
        end note
        
        :执行权限测试;
        if (具有Root权限?) then (是)
            :记录威胁: ROOT_WRITE_ACCESS;
        else (否)
            :权限检测通过;
        endif
        
    end fork
}

partition "Hook框架检测" {
    fork
        :Frida检测;
        note right
          • frida-server进程
          • frida-agent库
          • gum-js-loop线程
          • /data/local/tmp/re.frida.server
        end note
        
        :检查Frida特征;
        if (检测到Frida?) then (是)
            :记录威胁: FRIDA_DETECTED;
        else (否)
            :Frida检测通过;
        endif
        
    fork again
        :Xposed检测;
        note left
          • de.robv.android.xposed.XposedBridge
          • /data/data/de.robv.android.xposed.installer
          • XposedHelpers类
        end note
        
        :检查Xposed特征;
        if (检测到Xposed?) then (是)
            :记录威胁: XPOSED_DETECTED;
        else (否)
            :Xposed检测通过;
        endif
        
    fork again
        :Substrate检测;
        note right
          • com.saurik.substrate
          • libsubstrate.so
          • MSHookFunction符号
        end note
        
        :检查Substrate特征;
        if (检测到Substrate?) then (是)
            :记录威胁: SUBSTRATE_DETECTED;
        else (否)
            :Substrate检测通过;
        endif
        
    fork again
        :JNI函数表完整性;
        note left
          检查关键JNI函数是否被Hook
          • RegisterNatives
          • FindClass
          • GetMethodID
        end note
        
        :验证JNI函数表;
        if (JNI函数被Hook?) then (是)
            :记录威胁: JNI_HOOKED;
        else (否)
            :JNI完整性通过;
        endif
        
    end fork
}

partition "网络安全检测" {
    fork
        :代理检测;
        note right
          • 系统代理设置
          • HTTP/HTTPS代理
          • SOCKS代理
        end note
        
        :检查网络代理;
        if (发现代理设置?) then (是)
            :记录威胁: PROXY_DETECTED;
        else (否)
            :代理检测通过;
        endif
        
    fork again
        :VPN检测;
        note left
          • VPN接口检测
          • 路由表分析
          • DNS设置检查
        end note
        
        :检查VPN连接;
        if (发现VPN连接?) then (是)
            :记录威胁: VPN_DETECTED;
        else (否)
            :VPN检测通过;
        endif
        
    fork again
        :网络监听检测;
        note right
          检查可疑的网络监听端口
          分析网络流量特征
        end note
        
        :检查网络监听;
        if (发现可疑监听?) then (是)
            :记录威胁: NETWORK_MONITOR;
        else (否)
            :网络检测通过;
        endif
        
    end fork
}

partition "代码完整性检测" {
    fork
        :关键代码段校验;
        note left
          计算核心函数的校验和
          检测代码是否被篡改
        end note
        
        :验证代码完整性;
        if (代码被篡改?) then (是)
            :记录威胁: CODE_MODIFIED;
        else (否)
            :代码完整性通过;
        endif
        
    fork again
        :内存保护检查;
        note right
          检查关键内存区域保护
          验证内存访问权限
        end note
        
        :检查内存保护;
        if (内存保护异常?) then (是)
            :记录威胁: MEMORY_UNPROTECTED;
        else (否)
            :内存保护正常;
        endif
        
    end fork
}

partition "威胁评估和响应" {
    :统计威胁数量;
    :计算安全分数;
    
    note right
      安全分数计算公式:
      基础分数: 100
      每个威胁扣分: -10到-20
      最低分数: 0
    end note
    
    if (安全分数 < 30?) then (是)
        :威胁等级: 高危;
        :触发反制措施;
        
        fork
            :数据自毁;
        fork again
            :功能降级;
        fork again
            :日志清理;
        end fork
        
    elseif (安全分数 < 60?) then (是)
        :威胁等级: 中危;
        :启用额外保护;
    else (否)
        :威胁等级: 低危;
        :正常运行模式;
    endif
}

partition "结果封装" {
    :创建SecurityResult对象;
    
    fork
        :设置调试状态;
    fork again
        :设置模拟器状态;
    fork again
        :设置Root状态;
    fork again
        :设置Hook状态;
    fork again
        :设置网络安全状态;
    fork again
        :设置安全分数;
    fork again
        :设置威胁详情列表;
    fork again
        :设置检测时间戳;
    end fork
}

:返回安全检测结果;

stop

note right
  <b>检测覆盖面</b>
  • 8大类安全威胁
  • 25+具体检测项
  • 实时动态检测
  • 智能威胁评估
end note

note left
  <b>响应策略</b>
  • 分级威胁处理
  • 动态反制措施
  • 功能降级保护
  • 数据安全销毁
end note

@enduml