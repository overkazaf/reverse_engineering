@startuml Anti_Reverse_Protection_Flow
!theme vibrant
skinparam backgroundColor White
skinparam shadowing false
title RiskControl SDK - 反逆向保护流程

start

:SDK初始化阶段;

partition "初始化时保护" {
    fork
        :字符串混淆初始化;
        
        partition ".init_array解密" {
            :程序启动时自动执行;
            :从只读段读取加密数据;
            :使用内置密钥解密AES密钥;
            :解密关键字符串到内存;
            :设置字符串访问函数指针;
        }
        
        note left
          加密字符串示例:
          • 类名: "com/riskcontrol/RiskControlSDK"
          • 方法名: "getDeviceFingerprint"
          • 系统属性名: "ro.debuggable"
        end note
        
    fork again
        :控制流混淆初始化;
        
        partition "代码平坦化" {
            :创建虚假分支;
            :插入垃圾指令;
            :随机化跳转表;
            :生成迷惑性代码路径;
        }
        
        note right
          混淆技术:
          • 指令替换
          • 分支预测干扰
          • 寄存器混淆
          • 时序攻击防护
        end note
        
    fork again
        :内存保护初始化;
        
        partition "关键代码段保护" {
            :标记敏感函数;
            :设置内存页权限;
            :注册页面异常处理;
            :启用写时保护机制;
        }
        
    end fork
}

partition "运行时反调试保护" {
    :启动反调试监控线程;
    
    repeat
        fork
            :TracerPid检测;
            :读取/proc/self/status;
            :解析TracerPid字段;
            
            if (TracerPid > 0?) then (是)
                :检测到调试器;
                :触发反制措施;
                
                partition "调试器反制" {
                    fork
                        :ptrace反附加;
                        :调用ptrace(PTRACE_TRACEME);
                    fork again
                        :进程分叉检测;
                        :fork子进程监控父进程;
                    fork again
                        :信号干扰;
                        :发送SIGSTOP信号;
                    end fork
                }
                
            else (否)
                :调试检测通过;
            endif
            
        fork again
            :调试端口检测;
            :扫描常用调试端口;
            note left
              检查端口:
              • 23946 (JDWP)
              • 1234 (gdbserver)
              • 8700 (IDA Pro)
            end note
            
            if (发现调试端口?) then (是)
                :记录调试威胁;
                :执行端口干扰;
            else (否)
                :端口检测通过;
            endif
            
        fork again
            :动态库检测;
            :扫描/proc/self/maps;
            :查找可疑库特征;
            
            note right
              可疑库关键字:
              • "frida"
              • "xposed" 
              • "substrate"
              • "cydia"
            end note
            
            if (发现Hook库?) then (是)
                :记录Hook威胁;
                :执行库卸载尝试;
            else (否)
                :库检测通过;
            endif
            
        fork again
            :JNI函数表完整性;
            :检查关键JNI函数指针;
            :计算函数表校验和;
            
            if (函数表被篡改?) then (是)
                :记录JNI Hook威胁;
                :尝试恢复函数表;
            else (否)
                :JNI完整性正常;
            endif
            
        end fork
        
        :休眠随机时间间隔;
        note right: 避免被检测到固定周期
        
    repeat while (监控线程运行中?)
}

partition "代码完整性保护" {
    :启动完整性监控线程;
    
    repeat
        :遍历关键函数列表;
        
        repeat
            :计算函数当前校验和;
            :与原始校验和对比;
            
            if (校验和不匹配?) then (是)
                :检测到代码篡改;
                
                partition "代码篡改响应" {
                    fork
                        :记录篡改位置;
                        :分析篡改模式;
                    fork again
                        :尝试代码修复;
                        :从备份恢复原始代码;
                    fork again
                        :如果修复失败;
                        :触发数据自毁;
                    end fork
                }
                
            else (否)
                :代码完整性正常;
            endif
            
        repeat while (还有函数需要检查?)
        
        :延时下一轮检查;
        
    repeat while (完整性监控运行中?)
}

partition "Hook框架检测与对抗" {
    fork
        :Frida检测模块;
        
        repeat
            :检查frida-server进程;
            :扫描frida特征字符串;
            :检测gum-js-loop线程;
            :分析内存映射异常;
            
            if (检测到Frida?) then (是)
                :记录Frida威胁;
                :执行Frida对抗;
                
                partition "Frida对抗措施" {
                    fork
                        :端口扫描干扰;
                        :连接frida端口发送垃圾数据;
                    fork again
                        :内存保护加强;
                        :关键数据区域随机化;
                    fork again
                        :进程隐藏;
                        :修改进程名称;
                    end fork
                }
                
            else (否)
                :Frida检测通过;
            endif
            
            :间隔检测;
            
        repeat while (Frida监控运行中?)
        
    fork again
        :Xposed检测模块;
        
        repeat
            :检查Xposed类加载器;
            :扫描XposedBridge类;
            :检测de.robv.android.xposed包;
            :分析方法Hook特征;
            
            if (检测到Xposed?) then (是)
                :记录Xposed威胁;
                :执行Xposed对抗;
                
                partition "Xposed对抗措施" {
                    fork
                        :类加载器隔离;
                        :创建独立类加载环境;
                    fork again
                        :方法调用验证;
                        :检查方法调用链完整性;
                    fork again
                        :反射调用混淆;
                        :动态方法调用路径;
                    end fork
                }
                
            else (否)
                :Xposed检测通过;
            endif
            
            :间隔检测;
            
        repeat while (Xposed监控运行中?)
        
    end fork
}

partition "内存保护机制" {
    fork
        :敏感数据保护;
        
        partition "数据加密存储" {
            :识别敏感数据;
            :动态生成加密密钥;
            :使用AES加密存储;
            :内存中仅保留解密接口;
        }
        
        note left
          敏感数据包括:
          • 设备指纹数据
          • 加密密钥
          • 算法参数
          • 配置信息
        end note
        
    fork again
        :内存页面保护;
        
        partition "页面保护策略" {
            :关键代码段设为只读;
            :数据段写时保护;
            :栈保护机制启用;
            :堆溢出检测;
        }
        
    fork again
        :内存访问监控;
        
        repeat
            :注册SIGSEGV信号处理;
            :监控异常内存访问;
            
            if (检测到异常访问?) then (是)
                :分析访问模式;
                :判断是否为攻击行为;
                
                if (确认为攻击?) then (是)
                    :记录攻击行为;
                    :执行内存保护反制;
                else (否)
                    :正常内存访问;
                endif
                
            else (否)
                :内存访问正常;
            endif
            
        repeat while (内存监控运行中?)
        
    end fork
}

partition "反制措施执行" {
    :评估威胁等级;
    
    if (威胁等级?) then (高危)
        :执行严厉反制;
        
        partition "高危反制措施" {
            fork
                :立即数据自毁;
                :清零敏感内存区域;
            fork again
                :功能完全禁用;
                :返回错误状态;
            fork again
                :进程退出;
                :调用exit()或abort();
            end fork
        }
        
    elseif (威胁等级?) then (中危)
        :执行中等反制;
        
        partition "中危反制措施" {
            fork
                :功能降级;
                :禁用高级功能;
            fork again
                :增强监控;
                :提高检测频率;
            fork again
                :数据混淆;
                :返回虚假数据;
            end fork
        }
        
    else (低危)
        :执行轻微反制;
        
        partition "低危反制措施" {
            fork
                :警告日志;
                :记录威胁信息;
            fork again
                :延时响应;
                :增加随机延迟;
            fork again
                :加强检测;
                :启用额外保护;
            end fork
        }
        
    endif
}

partition "保护状态维护" {
    :更新保护状态;
    :调整保护强度;
    :优化检测策略;
    
    note right
      状态维护包括:
      • 威胁等级评估
      • 保护效果分析  
      • 性能影响监控
      • 策略动态调整
    end note
}

:保护流程持续运行;

stop

note right
  <b>保护层次</b>
  • 编译时混淆保护
  • 运行时动态保护
  • 内存级别保护
  • 系统级别对抗
end note

note left
  <b>技术特点</b>
  • 多层次防护体系
  • 实时威胁检测
  • 动态反制响应
  • 自适应保护强度
end note

@enduml